#include "main.h"
#include <string.h>
#include <stdarg.h>

#define DMA2_BASE 0x40026400
#define DMA_SM0AR 0x1C + 0x18 * 2
#define DMA_SPAR 0x18 + 0x18 * 2
#define DMA_SNDTR 0x14 + 0x18 * 2
#define DMA_SCR 0x10 + 0x18 * 2
#define DMA_LIFCR 0x08

#define UART2_BASE 0x40004400
#define UART_BRR 0x08
#define UART_CR1 0x0C
#define UART_SR 0x00
#define UART_DR 0x04
#define UART_CR3 0x14

#define GPIOA_BASE 0x40020000
#define GPIO_AFRL 0x20
#define GPIO_MODER 0x00

#define RCC_BASE 0x40023800
#define RCC_AHB1ENR 0x30
#define RCC_APB2ENR 0x44
#define RCC_APB1ENR 0x40

#define FLASH_BASE 0x40023C00
#define FLASH_CR 0x10
#define FLASH_SR 0x0C
#define FLASH_KEYR 0x04

#define TIMER1_BASE 0x40010000
#define TIM_CR1 0x00
#define TIM_PSC 0x28
#define TIM_ARR 0x2C
#define TIM_DIER 0x0C
#define TIM_SR 0x10

#define ADC1_BASE 0x40012000
#define ADC_CR2 0x08
#define ADC_SMPR1 0x0C
#define ADC_CCR 0x304
#define ADC_JSQR 0x38
#define ADC_SR 0x00
#define ADC_JDR1 0x3C

int firmware_updated, counter = 0;
char rxbuff[1000];

void DMA2_Init();
void UART2_Init();
void UART_Write(uint8_t data);
void UART_Write_String(char* s, ...);
char UART_Read();
__attribute__((section(".RamFunc"))) void FLASH_Erase(uint8_t sector);
__attribute__((section(".RamFunc"))) void FLASH_Write(uint8_t* addr, uint8_t data);
__attribute__((section(".RamFunc"))) void update();
void TIMER1_Init();
void delay(unsigned int t);
void ADC_Init();
float ADC_Measure();
float temp_measure();

int main() {
	DMA2_Init();
	UART2_Init();
	TIMER1_Init();
	ADC_Init();
	while (1) {
		if (firmware_updated == 1) {
			__asm("cpsid i");
			update();
		}
		float temp = temp_measure();
		UART_Write_String("Room temperature is: %.2f\n", temp);
		delay(1000);
	}
	return 0;
}

void ADC_Init() {
	uint32_t* ADC_EN = (uint32_t*)(RCC_BASE + RCC_APB2ENR);
	*ADC_EN |= (0b01 << 8);
	uint32_t* ADC1_SMPR1 = (uint32_t*)(ADC1_BASE + ADC_SMPR1);
	*ADC1_SMPR1 &= ~(0b111 << 18);
	*ADC1_SMPR1 |= (0b111 << 18);
	uint32_t* ADC1_JSQR = (uint32_t*)(ADC1_BASE + ADC_JSQR);
	*ADC1_JSQR &= ~(0x1F << 15);
	*ADC1_JSQR |= (16 << 15);
	*ADC1_JSQR &= ~(0b11 << 20);
	uint32_t* ADC1_CCR = (uint32_t*)(ADC1_BASE + ADC_CCR);
	*ADC1_CCR |= (0b01 << 23);
	uint32_t* ADC1_CR2 = (uint32_t*)(ADC1_BASE + ADC_CR2);
	*ADC1_CR2 |= (0b01 << 0);
}

float ADC_Measure() {
	uint32_t* ADC1_CR2 = (uint32_t*)(ADC1_BASE + ADC_CR2);
	*ADC1_CR2 |= (0b01 << 22);
	uint32_t* ADC1_SR = (uint32_t*)(ADC1_BASE + ADC_SR);
	while (((*ADC1_SR >> 2) & 1) == 0);
	*ADC1_SR &= ~(0b01 << 2);
	uint32_t* ADC1_JDR1 = (uint32_t*)(ADC1_BASE + ADC_JDR1);
	return (*ADC1_JDR1) / 4095.0 * 3.0;
}

float temp_measure() {
	float vsense = ADC_Measure();
	float v25 = 0.76;
	float avg_slope = 2.5/1000;
	float recorded_temp = ((vsense - v25)/avg_slope) + 25;
	return recorded_temp;
}

void TIMER1_Init() {
	uint32_t* TIMER1_EN = (uint32_t*)(RCC_BASE + RCC_APB2ENR);
	*TIMER1_EN |= (0b01 << 0);
	uint16_t* TIMER1_CR1 = (uint16_t*)(TIMER1_BASE + TIM_CR1);
	*TIMER1_CR1 |= (0b01 << 0);
	uint16_t* TIMER1_PSC = (uint16_t*)(TIMER1_BASE + TIM_PSC);
	*TIMER1_PSC = 16000 - 1;
	uint16_t* TIMER1_ARR = (uint16_t*)(TIMER1_BASE + TIM_ARR);
	*TIMER1_ARR = 1;
	uint16_t* TIMER1_DIER = (uint16_t*)(TIMER1_BASE + TIM_DIER);
	*TIMER1_DIER |= (0b01 << 0);
	uint32_t* NVIC_ISER0 = (uint32_t*)0xE000E100;
	*NVIC_ISER0 |= (0b01 << 25);
}

void TIM1_UP_TIM10_IRQHandler() {
	counter++;
	uint16_t* TIMER1_SR = (uint16_t*)(TIMER1_BASE + TIM_SR);
	*TIMER1_SR &= ~(0b01 << 0);
}

void delay(unsigned int t) {
	counter = 0;
	while (t >= counter);
}

void DMA2_Init() {
	uint32_t* DMA2_EN = (uint32_t*)(RCC_BASE + RCC_AHB1ENR);
	*DMA2_EN |= (0b01 << 22);
	uint32_t* DMA2_SM0AR = (uint32_t*)(DMA2_BASE + DMA_SM0AR);
	*DMA2_SM0AR = rxbuff;
	uint32_t* DMA2_SPAR = (uint32_t*)(DMA2_BASE + DMA_SPAR);
	*DMA2_SPAR = 0x40011004;
	uint32_t* DMA2_SNDTR = (uint32_t*)(DMA2_BASE + DMA_SNDTR);
	*DMA2_SNDTR = sizeof(rxbuff);
	uint32_t* DMA2_SCR = (uint32_t*)(DMA2_BASE + DMA_SCR);
	*DMA2_SCR &= ~(0b111 << 25);
	*DMA2_SCR |= (0b100 << 25);
	*DMA2_SCR |= (0b01 << 0) | (0b01 << 10) | (0b01 << 8) | (0b01 << 4);
}

void DMA2_Stream2_IRQHandler() {
	uint32_t* DMA2_LIFCR = (uint32_t*)(DMA2_BASE + DMA_LIFCR);
	*DMA2_LIFCR |= (0b01 << 21);
	firmware_updated = 1;
}

void UART2_Init() {
	uint32_t* GPIOA_EN = (uint32_t*)(RCC_BASE + RCC_AHB1ENR);
	*GPIOA_EN |= (0b01 << 0);
	uint32_t* UART2_EN = (uint32_t*)(RCC_BASE + RCC_APB1ENR);
	*UART2_EN |= (0b01 << 17);

	uint32_t* GPIOA_MODER = (uint32_t*)(GPIOA_BASE + GPIO_MODER);
	*GPIOA_MODER &= ~(0x0F << 4);
	*GPIOA_MODER |= (0x0A << 4);
	uint32_t* GPIOA_AFRL = (uint32_t*)(GPIOA_BASE + GPIO_AFRL);
	*GPIOA_AFRL &= ~(0xFF << 8);
	*GPIOA_AFRL |= (0x77 << 8);

	uint32_t* UART2_BRR = (uint32_t*)(UART2_BASE + UART_BRR);
	*UART2_BRR = (104 << 4) | (3 << 0);
	uint32_t* UART2_CR1 = (uint32_t*)(UART2_BASE + UART_CR1);
	*UART2_CR1 |= (0b01 << 13) | (0b01 << 12) | (0b01 << 10) | (0b01 << 3) | (0b01 << 2);

#if 0
	*UART2_CR1 |= (0b01 << 5);
	uint32_t* NVIC_ISER1 = (uint32_t*)0xE000E104;
	*NVIC_ISER1 |= (0b01 << 6);
#else
	uint32_t* UART2_CR3 = (uint32_t*)(UART2_BASE + UART_CR3);
	*UART2_CR3 |= (0b01 << 6);
	uint32_t* NVIC_ISER1 = (uint32_t*)0xE000E104;
	*NVIC_ISER1 |= (0b01 << 26);
#endif
}

void UART_Write(uint8_t data) {
	uint32_t* UART2_DR = (uint32_t*)(UART2_BASE + UART_DR);
	uint32_t* UART2_SR = (uint32_t*)(UART2_BASE + UART_SR);
	while (((*UART2_SR >> 6) & 1) == 0);
	*UART2_DR = data;
	while (((*UART2_SR >> 7) & 1) == 0);
}

void UART_Write_String(char* s, ...) {
	va_list arg;
	va_start(arg, s);
	char rxbuff[128] = {0};
	vsprintf(rxbuff, s, arg);
	va_end(arg);
	unsigned int l = strlen(rxbuff);
	for (int i = 0; i < l; i++) {
		UART_Write(rxbuff[i]);
	}
}

char UART_Read() {
	uint32_t* UART2_DR = (uint32_t*)(UART2_BASE + UART_DR);
	uint32_t* UART2_SR = (uint32_t*)(UART2_BASE + UART_SR);
	while (((*UART2_SR >> 5) & 1) == 0);
	char data = *UART2_DR;
	return data;
}

__attribute__((section(".RamFunc"))) void FLASH_Erase(uint8_t sector) {
	uint32_t* flash_CR = (uint32_t*)(FLASH_BASE + FLASH_CR);
	uint32_t* flash_SR = (uint32_t*)(FLASH_BASE + FLASH_SR);
	uint32_t* flash_Keyr = (uint32_t*)(FLASH_BASE + FLASH_KEYR);
	if (((*flash_SR >> 16) & 1) == 0) {
		if (((*flash_CR >> 31) & 1) == 1) {
			*flash_Keyr = 0x45670123;
			*flash_Keyr = 0xCDEF89AB;
		}
		*flash_CR &= ~(0x0F << 3);
		*flash_CR |= (0b01 << 1) | (0b01 << 16) | (sector << 3);
		while (((*flash_SR >> 16) & 1) == 1);
	}
}

__attribute__((section(".RamFunc"))) void FLASH_Write(uint8_t* addr, uint8_t data) {
	uint32_t* flash_CR = (uint32_t*)(FLASH_BASE + FLASH_CR);
	uint32_t* flash_SR = (uint32_t*)(FLASH_BASE + FLASH_SR);
	uint32_t* flash_Keyr = (uint32_t*)(FLASH_BASE + FLASH_KEYR);
	if (((*flash_SR >> 16) & 1) == 0) {
		if (((*flash_CR >> 31) & 1) == 1) {
			*flash_Keyr = 0x45670123;
			*flash_Keyr = 0xCDEF89AB;
		}
		*flash_CR |= (0b01 << 0);
		*flash_CR &= ~(0b11 << 8);
		*addr = data;
		while (((*flash_SR >> 16) & 1) == 1);
	}
}

__attribute__((section(".RamFunc"))) void update() {
	FLASH_Erase(0);
	for (int i = 0; i < sizeof(rxbuff); i++) {
		FLASH_Write(0x08000000 + i, rxbuff[i]);
	}
}
