#include "main.h"

#define I2C1_BASE 0x40005400
#define I2C_CR1 0x00
#define I2C_CR2 0x04
#define I2C_CCR 0x1C
#define I2C_SR1 0x14
#define I2C_SR2 0x18
#define I2C_DR 0x10

#define RCC_BASE 0x40023800
#define RCC_APB1ENR 0x40
#define RCC_AHB1ENR 0x30
#define RCC_APB2ENR 0x44

#define GPIOB_BASE 0x40020400
#define GPIOA_BASE 0x40020000
#define GPIO_AFRH 0x24
#define GPIO_AFRL 0x20
#define GPIO_MODER 0x00
#define GPIOD_BASE 0x40020C00
#define GPIO_ODR 0x14

#define TIMER1_BASE 0x40010000
#define TIM_CR1 0x00
#define TIM_PSC 0x28
#define TIM_ARR 0x2C
#define TIM_DIER 0x0C
#define TIM_SR 0x10

#define DMA2_BASE 0x40026400
#define DMA_SM0AR 0x1C + 0x18 * 2
#define DMA_SPAR 0x18 + 0x18 * 2
#define DMA_SNDTR 0x14 + 0x18 * 2
#define DMA_SCR 0x10 + 0x18 * 2
#define DMA_LIFCR 0x08

#define UART1_BASE 0x40004400
#define UART_BRR 0x08
#define UART_CR1 0x0C
#define UART_SR 0x00
#define UART_DR 0x04
#define UART_CR3 0x14

#define FLASH_BASE 0x40023C00
#define FLASH_CR 0x10
#define FLASH_SR 0x0C
#define FLASH_KEYR 0x04

int16_t x, y, z;
unsigned int firmware_updated, counter = 0;
char rxbuff[1000];

void I2C1_Init();
void I2C_Write(uint8_t addr, uint8_t data);
uint8_t I2C_Read(uint8_t addr);
void TIMER1_Init();
void LED_Init();
void LED_Toggle(uint8_t pin);
void LED_Blink(uint8_t pin, uint8_t state);
void LED_Matrix();
void delay(unsigned int t);
void DMA2_Init();
void UART2_Init();
void UART_Write(uint8_t data);
void UART_Write_String(char* s);
char UART_Read();
__attribute__((section(".RamFunc"))) void FLASH_Erase(uint8_t sector);
__attribute__((section(".RamFunc"))) void FLASH_Write(uint8_t* addr, uint8_t data);
__attribute__((section(".RamFunc"))) void update();

int main() {
	LED_Init();
	I2C1_Init();
	TIMER1_Init();
	UART2_Init();
	DMA2_Init();
	uint8_t device = I2C_Read(0x0F);
	uint8_t CTRL_REG1A = 0b01010111;
	I2C_Write(0x20, CTRL_REG1A);
	while (1) {
		uint8_t HIGH, LOW;
		HIGH = I2C_Read(0x29);
		LOW = I2C_Read(0x28);
		x = (HIGH << 8) | LOW;

		HIGH = I2C_Read(0x2B);
		LOW = I2C_Read(0x2A);
		y = (HIGH << 8) | LOW;

		HIGH = I2C_Read(0x2D);
		LOW = I2C_Read(0x2C);
		z = (HIGH << 8) | LOW;

		LED_Matrix();
		UART_Write_String("Hello World\n");
	}
	return 0;
}

void I2C1_Init() {
	uint32_t* GPIOB_EN = (uint32_t*)(RCC_BASE + RCC_AHB1ENR);
	*GPIOB_EN |= (0b01 << 1);
	uint32_t* I2C1_EN = (uint32_t*)(RCC_BASE + RCC_APB1ENR);
	*I2C1_EN |= (0b01 << 21);

	uint32_t* GPIOB_MODER = (uint32_t*)(GPIOB_BASE + GPIO_MODER);
	*GPIOB_MODER &= ~(0b01 << 12);
	*GPIOB_MODER &= ~(0b01 << 18);
	*GPIOB_MODER |= (0b10 << 12) | (0b10 << 18);
	uint32_t* GPIOB_AFRL = (uint32_t*)(GPIOB_BASE + GPIO_AFRL);
	*GPIOB_AFRL &= ~(0b1111 << 24);
	*GPIOB_AFRL |= (0b0100 << 24);
	uint32_t* GPIOB_AFRH = (uint32_t*)(GPIOB_BASE + GPIO_AFRH);
	*GPIOB_AFRH &= ~(0b1111 << 4);
	*GPIOB_AFRH |= (0b0100 << 4);

	uint32_t* I2C1_CR2 = (uint32_t*)(I2C1_BASE + I2C_CR2);
	*I2C1_CR2 &= ~(0x3F << 0);
	*I2C1_CR2 |= (16 << 0);
	uint32_t* I2C1_CCR = (uint32_t*)(I2C1_BASE + I2C_CCR);
	*I2C1_CCR &= ~(0xFFF << 0);
	*I2C1_CCR |= (160 << 0);
	uint32_t* I2C1_CR1 = (uint32_t*)(I2C1_BASE + I2C_CR1);
	*I2C1_CR1 |= (0b01 << 0);
}

void I2C_Write(uint8_t addr, uint8_t data) {
	uint32_t* I2C1_CR1 = (uint32_t*)(I2C1_BASE + I2C_CR1);
	*I2C1_CR1 |= (0b01 << 8);								// start

	uint32_t* I2C1_SR1 = (uint32_t*)(I2C1_BASE + I2C_SR1);
	while(((*I2C1_SR1 >> 0) & 1) == 0);
	uint32_t* I2C1_DR = (uint32_t*)(I2C1_BASE + I2C_DR);
	*I2C1_DR = 0b00110010;
	while(((*I2C1_SR1 >> 1) & 1) == 0);						// wait till matching register's address
	uint32_t* I2C1_SR2 = (uint32_t*)(I2C1_BASE + I2C_SR2);
	uint8_t temp = *I2C1_SR2;

	while(((*I2C1_SR1 >> 10) & 1) == 1);
	*I2C1_DR = addr;
	while(((*I2C1_SR1 >> 2) & 1) == 0);
	while(((*I2C1_SR1 >> 10) & 1) == 1);
	*I2C1_DR = data;
	while(((*I2C1_SR1 >> 2) & 1) == 0);

	*I2C1_CR1 |= (0b01 << 9);								// stop
}

uint8_t I2C_Read(uint8_t addr) {
	uint32_t* I2C1_CR1 = (uint32_t*)(I2C1_BASE + I2C_CR1);
	*I2C1_CR1 &= ~(0b01 << 10);
	*I2C1_CR1 |= (0b01 << 8);

	uint32_t* I2C1_SR1 = (uint32_t*)(I2C1_BASE + I2C_SR1);
	while(((*I2C1_SR1 >> 0) & 1) == 0);
	uint32_t* I2C1_DR = (uint32_t*)(I2C1_BASE + I2C_DR);
	*I2C1_DR = 0b00110010;
	while(((*I2C1_SR1 >> 1) & 1) == 0);
	uint32_t* I2C1_SR2 = (uint32_t*)(I2C1_BASE + I2C_SR2);
	uint8_t temp = *I2C1_SR2;

	while(((*I2C1_SR1 >> 10) & 1) == 1);
	*I2C1_DR = addr;
	while(((*I2C1_SR1 >> 2) & 1) == 0);
	while(((*I2C1_SR1 >> 10) & 1) == 1);

	*I2C1_CR1 |= (0b01 << 8);
	while(((*I2C1_SR1 >> 0) & 1) == 0);
	*I2C1_DR = 0b00110011;
	while(((*I2C1_SR1 >> 1) & 1) == 0);
	temp = *I2C1_SR2;
	while(((*I2C1_SR1 >> 10) & 1) == 1);

	while(((*I2C1_SR1 >> 6) & 1) == 0);						// Read data
	uint8_t data = *I2C1_DR;

	*I2C1_CR1 |= (0b01 << 9);
	return data;
}

void LED_Init() {
	uint32_t* GPIOD_EN = (uint32_t*)(RCC_BASE + RCC_AHB1ENR);
	*GPIOD_EN |= (0b01 << 3);
	uint32_t* GPIOD_MODER = (uint32_t*)(GPIOD_BASE + GPIO_MODER);
	*GPIOD_MODER &= ~(0xFF << 24);
	*GPIOD_MODER |= (0x55 << 24);
}

void LED_Toggle(uint8_t pin) {
	uint32_t* GPIOD_ODR = (uint32_t*)(GPIOD_BASE + GPIO_ODR);
	*GPIOD_ODR ^= (0b01 << pin);
}

void LED_Blink(uint8_t pin, uint8_t state) {
	uint32_t* GPIOD_ODR = (uint32_t*)(GPIOD_BASE + GPIO_ODR);
	if (state == 1) {
		*GPIOD_ODR |= (0b01 << pin);
	} else {
		*GPIOD_ODR &= ~(0b01 << pin);
	}
}

void LED_Matrix() {
	if (x >= 3000) {
		LED_Blink(13, 0);
	} else if (x <= -3000) {
		LED_Blink(15, 0);
	}

	if (x >= 5000) {
		LED_Toggle(15);
		delay(50);
	} else if (x <= -5000) {
		LED_Toggle(13);
		delay(50);
	}

	if (y >= 3000) {
		LED_Blink(14, 0);
	} else if (y <= -3000) {
		LED_Blink(12, 0);
	}

	if (y >= 5000) {
		LED_Toggle(12);
		delay(50);
	} else if (y <= -5000) {
		LED_Toggle(14);
		delay(50);
	}
}

void TIMER1_Init() {
	uint32_t* TIMER1_EN = (uint32_t*)(RCC_BASE + RCC_APB2ENR);
	*TIMER1_EN |= (0b01 << 0);
	uint16_t* TIMER1_CR1 = (uint16_t*)(TIMER1_BASE + TIM_CR1);
	*TIMER1_CR1 |= (0b01 << 0);
	uint16_t* TIMER1_PSC = (uint16_t*)(TIMER1_BASE + TIM_PSC);
	*TIMER1_PSC = 16000 - 1;
	uint16_t* TIMER1_ARR = (uint16_t*)(TIMER1_BASE + TIM_ARR);
	*TIMER1_ARR = 1;
	uint16_t* TIMER1_DIER = (uint16_t*)(TIMER1_BASE + TIM_DIER);
	*TIMER1_DIER |= (0b01 << 0);
	uint32_t* NVIC_ISER0 = (uint32_t*)0xE000E100;
	*NVIC_ISER0 |= (0b01 << 25);
}

void TIM1_UP_TIM10_IRQHandler() {
	counter++;
	uint16_t* TIMER1_SR = (uint16_t*)(TIMER1_BASE + TIM_SR);
	*TIMER1_SR &= ~(0b01 << 0);
}

void delay(unsigned int t) {
	counter = 0;
	while (t >= counter);
}

void DMA2_Init() {
	uint32_t* DMA2_EN = (uint32_t*)(RCC_BASE + RCC_AHB1ENR);
	*DMA2_EN |= (0b01 << 22);
	uint32_t* DMA2_SM0AR = (uint32_t*)(DMA2_BASE + DMA_SM0AR);
	*DMA2_SM0AR = rxbuff;
	uint32_t* DMA2_SPAR = (uint32_t*)(DMA2_BASE + DMA_SPAR);
	*DMA2_SPAR = 0x40011004;
	uint32_t* DMA2_SNDTR = (uint32_t*)(DMA2_BASE + DMA_SNDTR);
	*DMA2_SNDTR = sizeof(rxbuff);
	uint32_t* DMA2_SCR = (uint32_t*)(DMA2_BASE + DMA_SCR);
	*DMA2_SCR &= ~(0b111 << 25);
	*DMA2_SCR |= (0b100 << 25);
	*DMA2_SCR |= (0b01 << 0) | (0b01 << 10) | (0b01 << 8) | (0b01 << 4);
}

void DMA2_Stream2_IRQHandler() {
	uint32_t* DMA2_LIFCR = (uint32_t*)(DMA2_BASE + DMA_LIFCR);
	*DMA2_LIFCR |= (0b01 << 21);
	firmware_updated = 1;
}

void UART2_Init() {
	uint32_t* GPIOB_EN = (uint32_t*)(RCC_BASE + RCC_AHB1ENR);
	*GPIOB_EN |= (0b01 << 1);
	uint32_t* UART2_EN = (uint32_t*)(RCC_BASE + RCC_APB1ENR);
	*UART2_EN |= (0b01 << 17);

	uint32_t* GPIOB_MODER = (uint32_t*)(GPIOB_BASE + GPIO_MODER);
	*GPIOB_MODER &= ~(0x0F << 12);
	*GPIOB_MODER |= (0x0A << 12);
	uint32_t* GPIOB_AFRL = (uint32_t*)(GPIOB_BASE + GPIO_AFRL);
	*GPIOB_AFRL &= ~(0xFF << 24);
	*GPIOB_AFRL |= (0x77 << 24);

	uint32_t* UART1_BRR = (uint32_t*)(UART1_BASE + UART_BRR);
	*UART1_BRR = (104 << 4) | (3 << 0);
	uint32_t* UART1_CR1 = (uint32_t*)(UART1_BASE + UART_CR1);
	*UART1_CR1 |= (0b01 << 13) | (0b01 << 12) | (0b01 << 10) | (0b01 << 3) | (0b01 << 2);

#if 0
	*UART1_CR1 |= (0b01 << 5);
	uint32_t* NVIC_ISER1 = (uint32_t*)0xE000E104;
	*NVIC_ISER1 |= (0b01 << 5);
#else
	uint32_t* UART1_CR3 = (uint32_t*)(UART1_BASE + UART_CR3);
	*UART1_CR3 |= (0b01 << 6);
	uint32_t* NVIC_ISER1 = (uint32_t*)0xE000E104;
	*NVIC_ISER1 |= (0b01 << 26);
#endif
}

void UART_Write(uint8_t data) {
	uint32_t* UART1_DR = (uint32_t*)(UART1_BASE + UART_DR);
	uint32_t* UART1_SR = (uint32_t*)(UART1_BASE + UART_SR);
	while (((*UART1_SR >> 6) & 1) == 0);
	*UART1_DR = data;
	while (((*UART1_SR >> 7) & 1) == 0);
}

void UART_Write_String(char* s) {
	unsigned int l = strlen(s);
	for (int i = 0; i < l; i++) {
		UART_Write(s[i]);
	}
}

char UART_Read() {
	uint32_t* UART1_DR = (uint32_t*)(UART1_BASE + UART_DR);
	uint32_t* UART1_SR = (uint32_t*)(UART1_BASE + UART_SR);
	while (((*UART1_SR >> 5) & 1) == 0);
	char data = *UART1_DR;
	return data;
}

__attribute__((section(".RamFunc"))) void FLASH_Erase(uint8_t sector) {
	uint32_t* flash_CR = (uint32_t*)(FLASH_BASE + FLASH_CR);
	uint32_t* flash_SR = (uint32_t*)(FLASH_BASE + FLASH_SR);
	uint32_t* flash_Keyr = (uint32_t*)(FLASH_BASE + FLASH_KEYR);
	if (((*flash_SR >> 16) & 1) == 0) {
		if (((*flash_CR >> 31) & 1) == 1) {
			*flash_Keyr = 0x45670123;
			*flash_Keyr = 0xCDEF89AB;
		}
		*flash_CR &= ~(0x0F << 3);
		*flash_CR |= (0b01 << 1) | (0b01 << 16) | (sector << 3);
		while (((*flash_SR >> 16) & 1) == 1);
	}
}

__attribute__((section(".RamFunc"))) void FLASH_Write(uint8_t* addr, uint8_t data) {
	uint32_t* flash_CR = (uint32_t*)(FLASH_BASE + FLASH_CR);
	uint32_t* flash_SR = (uint32_t*)(FLASH_BASE + FLASH_SR);
	uint32_t* flash_Keyr = (uint32_t*)(FLASH_BASE + FLASH_KEYR);
	if (((*flash_SR >> 16) & 1) == 0) {
		if (((*flash_CR >> 31) & 1) == 1) {
			*flash_Keyr = 0x45670123;
			*flash_Keyr = 0xCDEF89AB;
		}
		*flash_CR |= (0b01 << 0);
		*flash_CR &= ~(0b11 << 8);
		*addr = data;
		while (((*flash_SR >> 16) & 1) == 1);
	}
}

__attribute__((section(".RamFunc"))) void update() {
	FLASH_Erase(0);
	for (int i = 0; i < sizeof(rxbuff); i++) {
		FLASH_Write(0x08000000 + i, rxbuff[i]);
	}
}
